ЧАСТЬ РАЗРАБОТЧИКОВ

6.2.1.1. Технологии

Среди возможных способов реализации компьютерного зрения было выбрано распознавание QR-кодов. Оно было выбрано из-за недостатков других способов: распознавание с помощью обученной модели было отклонено из-за длительности создания этой самой модели и присущей ей неточности. Распознавание локальных особенностей было отклонено из-за сложности реализации его в Android Studio. Распознавание текста имеет огромное количество API, но все из них сталкиваются из одной или несколькими проблемами – незнание кириллицы, неточность распознавания и дороговизна получения этого API. Поэтому было выбрано распознавание QR-кодов – как самый простой и точный способ в компьютерном зрении. Для этого была выбрана библиотека Zxing, так как она более проста во внедрении и реализации её функционала, чем другие.

6.2.1.2. Структура приложения

В Android Studio файлы, с которыми я работал, находятся в папках java/com.example.kostroma_geroicheskaya (активности, написанные на Java) и res/layout (связанные, с определённой активностью, xml-файл, указывающий как должна выглядеть страница приложения у этой активности).

Кроме того, были использованы картинка diplom.png в папке res/drawable и шрифт old_soviet.OTF в папке res/font.
Напрямую я работал только с одним xml-файлом – activity_diplom.xml. В нём можно увидеть наверху “header”, содержащий кнопку “back”, возвращающую на предыдущую активность (вкладка наград), и заголовок-название вкладки. Ниже, на главном экране расположены картинка, на которой будет отображаться сгенерированный диплом, и кнопка, позволяющая сохранять сертификат в формате JPG.

6.2.1.3. Действия пользователя


Сканирования QR-кода.
Пользователь, находясь на странице «Я здесь был» нажимает кнопку “Использовать камеру”.


Далее у пользователя, если ещё не разрешено, запрашивается разрешение на использование камеры. В случае отказа пользователя перекинет обратно на страницу «Я здесь был».
Иначе будет включён сканнер QR-кодов и будет подписано “Просканируйте QR-код”.


Если пользователь просканирует нужный QR-код, то пользователю сообщат об этом, его перекинет на меню монумента и будет отмечен как выполненный пункт “Я здесь был”. Иначе, пользователю сообщат о неправильном QR-коде и также перекинут на меню монумента, но без отметки о выполнении.


Просмотр и сохранение сертификата
После полного прохождения маршрута, в меню наград станет доступна кнопка “Получить сертификат”. При нажатии пользователя перекидывает на страницу с сертификатом, где пользователь может выйти из неё, нажав на стрелочку назад, или сохранить сертификат в формате JPG, нажав кнопку “Сохранить как JPG”. 



6.2.1.4. Алгоритм работы
Первый скрипт, который использует разработчик, – это «NextScene». Он содержит лишь один метод «OpenNextScene», который предназначен для перехода между сценами.

Технология распознавания QR-кодов происходит в классе TechologyActivity. Сразу после перехода на страницу выбора способа отметить посещение монумента, создаются два поля типа String – fromQR, для хранения ссылки полученной из QR-кода, и fromLink, которое будет хранить ссылку на статью о том монументе, с которым сейчас взаимодействует пользователь.


На кнопку cameraButton повешена функция, которая сначала десериализует файл, в котором хранится информация о том, у какого именно монумента находится пользователь, и на и основании этой информации выбирается через switch ссылка на нужный монумент в fromLink. После этого запускается QR-сканнер с заданными настройками с помощью класса IntentInegrator.

После того, как QR-код был отсканирован, запускается переопределённый метод onActivityResult. В нём вытаскивается из отсканированного QR-кода данные, хранящиеся в нём (ссылка на статью о монументе) и сохраняется в fromQR. После чего сравниваются fromQR и fromLink, и если они совпадают, то, пользователю выводят сообщение о правильном сканировании QR-теста, сериализуется информация о том, что пользователь отметился на этом монументе, и перекидывает пользователь на страницу меню монумента. Иначе, сообщается о неправильном сканировании и также перекидывают пользователя в меню монумента, но в этот раз без сериализации.


Для возможности работы с QR-сканнером нужно было внедрить в проект библиотеку Zxing. Для этого в файл build.gradle.kts (:app) в часть dependencies нужно было вставить эти строчки implementation("com.google.zxing:core:3.4.1")
implementation("com.journeyapps:zxing-android-embedded:4.2.0").

Также, чтобы QR-сканнер всегда находился в вертикальном положении, в файл AndroidManifest.xml был вставлен следующий:

Создание диплома
Создание диплома полностью происходит в классе DiplomActivty. У класса есть поля: кнопки для выхода из страницы создания сертификата и сохранения его как JPG, ImageView, на котором будет отображаться созданный сертификат, строки, которые будут содержать информацию о пользователе и маршруте, по которому пользователь шёл, строка folderToSave, содержащая путь до папки, где будет сохранён диплом.


В методе onCreate устанвливается связь между кнопками и ImageView с соответствующими элементами в xml-файле. Также происходит десериализация информации о пользователе и маршруте и записываются в соответствующие строки. После чего устанавливаются функции на кнопки и запускается метод makeDiplom(), который и создаёт диплом.


Метод makeDiplom() создаёт Bitmap из изображения diplom, хранящимся в res/drawable. После чего создаётся Canvas на основе этого Bitmap и на него наносится текст в определённых координатах, а параметры текста заранее задаются через объект класса Paint. После нанесения текста на Bitmap, он устанавливается на ImageView.


При нажатии на кнопку сохранения вызывается метод Save(). В нём сначала проверяется, получилось создать или найти директорию для сохранения с помощью метода createFolder(). Если получилось, то создаётся файл с название “KG_Diplom”+дата и время создания. Он записывается в класс OutputStream, который и будет взаимодействовать с файловой системой устройства. После чего достаётся Bitmap из ImageView, компилируется как JPG и записывается в созданный файл. В конце вызывается метод MediaScannerConnection.scanFile, который указывает Галереи пользователя путь до файла, чтобы она его видела.



Метод createFolder() пытается создать директорию, где будут хранится дипломы. Если эта директория уже существуют, то просто возвращается true. Иначе создаётся эта директория, если удачно – то тоже возвращает true, иначе – false.

Также для работы этих классов нужно было запросить определённые разрешения в AndroidManifest.xml.

Также бы созданы нужные строки в файле strings.xml.


6.2.2.1. Выбор технологии

Каких-то особых библиотек не было использовано при разработке приложения. При этом использование Android Studio в качестве среды разработки на взгляд разработчика была идеальным решением, так как в этом семестре был специализированный предмет, на котором было получено достаточно знаний для разработки приложения. Использование других сред программирования, использующих другие языки программирования, сильно бы замедлило прогресс, что негативно сказалось бы на количестве функционала.

6.2.2.2. Структура приложения

В ходе разработки приложения разработчик пользовался несколькими папками, которые находились в app. Ниже представлены основные папки и файлы, для работы:
 – manifests – папка для объявления разрешений и активностей приложения;
 – java > com.exemple.kostroma_geroicheskaya – папка для работы java файлами, обеспечивающими основной функционал приложения.
 – res > drawable – папка с набором картинок;
 – res > font – папка с семейством шрифтом.
 – res > layout – папка с активностями (экранами) приложения.
 – res > values > colors.xml – файл с цветовыми значениями в 16-ричной форме.
 – res > values > strings.xml – файл со строковыми значениями.


6.2.2.3. Действия пользователя


moveToCurrentLocation(): перемещает камеру к текущему местоположению пользователя с анимацией.
isCameraAtCurrentLocation(): проверяет, находится ли камера в пределах заданного радиуса от текущего местоположения.
updateUIForLocationMode(): обновляет UI в зависимости от текущего режима отслеживания местоположения.
updateLocationOnMap(): обновляет местоположение на карте при получении новых данных о местоположении.
startLocationUpdates(): настраивает и запускает периодические обновления местоположения.
updatePlacemarkA(): обновляет или создает маркер, отображающий текущее местоположение пользователя.
onRequestPermissionsResult(): обрабатывает результат запроса разрешения на доступ к местоположению.

Этот код обеспечивает функциональность отслеживания и отображения местоположения пользователя на карте, включая различные режимы отображения и обработку разрешений.


Метод «updateCompassRotation» отвечает за плавное обновление ориентации компаса на экране:

Вычисляется целевой угол поворота на основе полученного азимута.
Рассчитывается разница между текущим и целевым углом поворота, учитывая возможность поворота через 0/360 градусов.
Создается «ValueAnimator» для плавной анимации поворота от текущего угла к целевому.
Настраивается длительность и тип интерполяции анимации.
Добавляется слушатель обновления анимации, который в реальном времени обновляет поворот изображения компаса.
Анимация запускается, что приводит к плавному повороту компаса к новому азимуту.
Этот подход обеспечивает плавное и визуально приятное обновление ориентации компаса, что улучшает пользовательский опыт при работе с картой и навигацией.


Методы «updateArrowOrientation» и «SensorEventListener»

Этот код отвечает за обработку данных от сенсоров устройства для определения его ориентации:
updateArrowOrientation: Метод для обновления направления стрелки на карте в соответствии с текущим азимутом.
sensorEventListener: Слушатель событий сенсора, который обрабатывает данные от акселерометра и магнитометра:
Сохраняет последние данные от каждого сенсора.
Когда получены данные от обоих сенсоров, вычисляет матрицу вращения и ориентацию устройства.
Преобразует азимут из радиан в градусы и нормализует его.
Применяет фильтр низких частот для сглаживания значений азимута.
Обновляет ориентацию стрелки на карте с заданным интервалом.
Этот код обеспечивает эффективное определение ориентации устройства и плавное обновление визуальных элементов на карте, что улучшает пользовательский опыт при работе с навигационными функциями приложения.



6.2.4.2. Алгоритм работы

Запуск приложения:
Пользователь открывает приложение и видит карту Яндекс.
На карте отображаются маркеры достопримечательностей.
Определение местоположения:
Приложение запрашивает разрешение на доступ к местоположению (если это первый запуск).
После получения разрешения, на карте появляется маркер текущего местоположения пользователя.
Карта автоматически центрируется на местоположении пользователя.
Навигация по карте:
Пользователь может свободно перемещаться по карте, используя жесты (свайп, зум).
При перемещении карты компас в углу экрана показывает текущую ориентацию карты.
Режимы отслеживания:
По умолчанию приложение находится в режиме следования (FOLLOW).
Пользователь может нажать на кнопку местоположения, чтобы переключиться между режимами:
FOLLOW: карта автоматически следует за местоположением пользователя.
NORMAL: карта остается статичной, но маркер пользователя продолжает обновляться.
Использование компаса:
Компас в углу экрана всегда показывает направление на север.
При нажатии на компас карта мгновенно ориентируется на север.
Ориентация на местности:
Маркер пользователя на карте (стрелка) всегда показывает, в каком направлении ориентировано устройство.
Это помогает пользователю понять, куда он смотрит в реальном мире относительно карты.
Просмотр достопримечательностей:
Пользователь видит маркеры достопримечательностей на карте.
Может приближать карту для более детального просмотра их расположения.
Движение пользователя:
При перемещении пользователя в реальном мире его маркер на карте соответственно обновляется.
В режиме FOLLOW карта автоматически перемещается, чтобы маркер оставался в центре.
Выход из приложения:
При сворачивании или закрытии приложения отслеживание местоположения прекращается.

Это приложение предоставляет пользователю интерактивную карту с функциями навигации и ориентирования, помогая легко определять свое местоположение относительно достопримечательностей и ориентироваться на местности.




6.2.5. Общие положения по разработке

Данный блок содержит некоторую информацию о проекте, которая распространяется на всех разработчик и частично на отдельных разработчиков карт и Qr-сканеров.

6.2.5.1. Выбор технологии 

Само приложение разрабатывалось в среде Android Studio по нескольким причинам. Простой и понятный интерфейс, который имеет множество инструментов: от отладки и до связи проекта с Git. Все активности строятся на интуитивно понятном и гибком языке разметки XML, один из используемых на выбор язык программирования Java, который во многом схож с уже знакомым C#, а также имеется возможность запуска приложений на виртуальной машине или на своем телефоне даже в режиме отладки. 
Если бы выбор пал на Unity, то команде потребовалось куда гораздо больше времени, для создания подобного приложения. А также много времени занял бы поиск нужных библиотек. Больше времени пришлось бы затратить и на тестирование, так как в этой среде разработки нет множества полезных инструментов для разработки приложений преимущественно под систему android.
Использование другого, более мощного движка, такого как Unreal Engine также усложнило бы задачу. Пришлось бы много времени потратить на изучение его функций, а также на изучение нового языка, так как данный движок использует C++ как основной язык разработки.
Таким образом, среда разработки Android Studio стала беспроигрышным вариантом, который включает в себя как простоту использования, так и простоту разработки.
Для реализации отображения и работы с картами был выбран Yandex Maps API по нескольким причинам. Во-первых, использование отечественных технологий развивает техническую составляющую в нашей стране и способствует скорейшему ее развитию. Во-вторых, вся документация русскоязычная (что, несомненно, большой плюс). В-третьих, на аналогичные технологии, например, Google Maps API, дает бесплатный пробный тариф, после которого следует выбрать платный. На выбранной же технологии тариф имеет более лояльные ограничения.
Среди возможных способов реализации компьютерного зрения было выбрано распознавание QR-кодов. Оно было выбрано из-за недостатков других способов: распознавание с помощью обученной модели было отклонено из-за длительности создания этой самой модели и присущей ей неточности. Распознавание локальных особенностей было отклонено из-за сложности реализации его в Android Studio. Распознавание текста имеет огромное количество API, но все из них сталкиваются из одной или несколькими проблемами – незнание кириллицы, неточность распознавания и дороговизна получения этого API. Поэтому было выбрано распознавание QR-кодов – как самый простой и точный способ в компьютерном зрении. Для этого была выбрана библиотека Zxing, так как она более проста во внедрении и реализации её функционала, чем другие.
